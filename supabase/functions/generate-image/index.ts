/**
 * Generate Image Edge Function
 * 
 * Generates images using multiple AI providers:
 * - OpenAI DALL-E 3 / GPT Image 1
 * - Google Gemini (NanoBanana / Imagen)
 * 
 * Users can select their preferred model for image generation.
 */
import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

// =============================================================================
// IMAGE MODEL REGISTRY
// =============================================================================

interface ImageModelConfig {
  provider: 'openai' | 'google';
  actualModel: string;
  displayName: string;
  displayNameAr: string;
  cost: number; // Cost per image
  supportsSize: string[];
}

const IMAGE_MODEL_REGISTRY: Record<string, ImageModelConfig> = {
  'openai/dall-e-3': {
    provider: 'openai',
    actualModel: 'dall-e-3',
    displayName: 'DALL-E 3',
    displayNameAr: 'دال-إي 3',
    cost: 0.04,
    supportsSize: ['1024x1024', '1024x1792', '1792x1024'],
  },
  'openai/gpt-image-1': {
    provider: 'openai',
    actualModel: 'gpt-image-1',
    displayName: 'GPT Image 1',
    displayNameAr: 'جي بي تي صور 1',
    cost: 0.04,
    supportsSize: ['1024x1024', '1024x1536', '1536x1024'],
  },
  'google/nanobanana': {
    provider: 'google',
    actualModel: 'gemini-2.0-flash-preview-image-generation',
    displayName: 'Gemini NanoBanana',
    displayNameAr: 'جيميني نانو بنانا',
    cost: 0.03,
    supportsSize: ['1024x1024', '1024x1536', '1536x1024'],
  },
};

// Default model if none specified
const DEFAULT_IMAGE_MODEL = 'openai/dall-e-3';

// =============================================================================
// PROVIDER API CALLS
// =============================================================================

/**
 * Generate image using OpenAI DALL-E 3 or GPT Image 1
 */
async function generateWithOpenAI(
  prompt: string, 
  modelConfig: ImageModelConfig,
  size: string,
  quality: string
): Promise<{ url: string; revisedPrompt?: string }> {
  const apiKey = Deno.env.get('OPENAI_API_KEY');
  if (!apiKey) throw new Error('OPENAI_API_KEY not configured');
  
  console.log(`Generating image with OpenAI ${modelConfig.actualModel}...`);
  
  // Validate size for this model
  let validSize = size;
  if (!modelConfig.supportsSize.includes(size)) {
    validSize = '1024x1024';
    console.log(`Size ${size} not supported, using ${validSize}`);
  }
  
  const response = await fetch('https://api.openai.com/v1/images/generations', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      model: modelConfig.actualModel,
      prompt,
      n: 1,
      size: validSize,
      quality: quality || 'auto',
      response_format: 'url',
    }),
  });
  
  if (!response.ok) {
    const errorText = await response.text();
    console.error('OpenAI image error:', response.status, errorText);
    
    if (response.status === 429) {
      throw new Error('Rate limit exceeded. Please try again later.');
    }
    if (response.status === 400 && errorText.includes('content_policy')) {
      throw new Error('Image generation blocked due to content policy. Please modify your prompt.');
    }
    
    throw new Error(`OpenAI image generation failed: ${response.status}`);
  }
  
  const data = await response.json();
  const imageData = data.data?.[0];
  
  if (!imageData?.url) {
    throw new Error('No image generated by OpenAI');
  }
  
  return {
    url: imageData.url,
    revisedPrompt: imageData.revised_prompt,
  };
}

/**
 * Generate image using Google Gemini (NanoBanana / Imagen)
 */
async function generateWithGoogle(
  prompt: string,
  modelConfig: ImageModelConfig,
  size: string
): Promise<{ url: string; revisedPrompt?: string }> {
  const apiKey = Deno.env.get('GOOGLE_API_KEY');
  if (!apiKey) throw new Error('GOOGLE_API_KEY not configured');
  
  console.log(`Generating image with Google ${modelConfig.actualModel}...`);
  
  const response = await fetch(
    `https://generativelanguage.googleapis.com/v1beta/models/${modelConfig.actualModel}:generateContent?key=${apiKey}`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: [{
          parts: [{ text: `Generate an image: ${prompt}` }]
        }],
        generationConfig: {
          responseModalities: ['image', 'text'],
        },
      }),
    }
  );
  
  if (!response.ok) {
    const errorText = await response.text();
    console.error('Google image error:', response.status, errorText);
    throw new Error(`Google image generation failed: ${response.status}`);
  }
  
  const data = await response.json();
  const parts = data.candidates?.[0]?.content?.parts || [];
  
  // Find the image part
  const imagePart = parts.find((p: any) => p.inlineData?.mimeType?.startsWith('image/'));
  
  if (!imagePart?.inlineData?.data) {
    throw new Error('No image generated by Google');
  }
  
  // Return as data URL (will be converted to proper storage URL later)
  const mimeType = imagePart.inlineData.mimeType || 'image/png';
  const dataUrl = `data:${mimeType};base64,${imagePart.inlineData.data}`;
  
  return {
    url: dataUrl,
    revisedPrompt: undefined,
  };
}

// =============================================================================
// MAIN HANDLER
// =============================================================================

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const { 
      prompt, 
      size = '1024x1024', 
      conversation_id, 
      negative_prompt, 
      style,
      model = DEFAULT_IMAGE_MODEL,
      quality = 'standard'
    } = await req.json()

    if (!prompt) {
      throw new Error('Prompt is required')
    }

    const supabaseUrl = Deno.env.get('SUPABASE_URL') ?? ''
    const supabaseKey = Deno.env.get('SUPABASE_ANON_KEY') ?? ''
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    const authHeader = req.headers.get('Authorization')

    if (!authHeader) {
      throw new Error('Missing Authorization header')
    }

    // Validate model selection
    const modelConfig = IMAGE_MODEL_REGISTRY[model];
    if (!modelConfig) {
      throw new Error(`Unknown image model: ${model}. Available: ${Object.keys(IMAGE_MODEL_REGISTRY).join(', ')}`);
    }

    // Check provider API key is available
    if (modelConfig.provider === 'openai' && !Deno.env.get('OPENAI_API_KEY')) {
      throw new Error('OpenAI API key not configured for image generation');
    }
    if (modelConfig.provider === 'google' && !Deno.env.get('GOOGLE_API_KEY')) {
      throw new Error('Google API key not configured for image generation');
    }

    const supabase = createClient(supabaseUrl, supabaseKey, {
      global: { headers: { Authorization: authHeader } },
    })

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      throw new Error('Invalid token')
    }

    console.log(`Generating image for prompt: "${prompt.substring(0, 50)}..." using ${model}`);

    // Construct the enhanced prompt
    let enhancedPrompt = prompt;

    if (style && style !== 'none') {
      enhancedPrompt += `. Style: ${style}.`;
    }

    if (negative_prompt) {
      enhancedPrompt += `. Avoid: ${negative_prompt}.`;
    }

    // Generate image based on provider
    let imageResult: { url: string; revisedPrompt?: string };
    
    if (modelConfig.provider === 'openai') {
      imageResult = await generateWithOpenAI(enhancedPrompt, modelConfig, size, quality);
    } else if (modelConfig.provider === 'google') {
      imageResult = await generateWithGoogle(enhancedPrompt, modelConfig, size);
    } else {
      throw new Error(`Unsupported provider: ${modelConfig.provider}`);
    }

    const tempImageUrl = imageResult.url;
    const revisedPrompt = imageResult.revisedPrompt || prompt;
    const cost = modelConfig.cost;

    // Download and upload to Supabase storage (for permanent storage)
    let permanentUrl = tempImageUrl;
    try {
      let imageBlob: Blob;
      
      if (tempImageUrl.startsWith('data:')) {
        // Handle base64 data URL (from Google)
        const base64Data = tempImageUrl.split(',')[1];
        const binaryString = atob(base64Data);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        imageBlob = new Blob([bytes], { type: 'image/png' });
      } else {
        // Handle URL (from OpenAI)
        const imageResponse = await fetch(tempImageUrl);
        if (imageResponse.ok) {
          imageBlob = await imageResponse.blob();
        } else {
          throw new Error('Failed to fetch image');
        }
      }
      
      const imageId = crypto.randomUUID();
      const fileName = `${user.id}/${imageId}.png`;
      
      // Create service client for storage operations
      const supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey);
      
      const { data: uploadData, error: uploadError } = await supabaseAdmin.storage
        .from('generated-images')
        .upload(fileName, imageBlob, {
          contentType: 'image/png',
          upsert: false,
        });

      if (!uploadError && uploadData) {
        // Get public URL
        const { data: publicUrlData } = supabaseAdmin.storage
          .from('generated-images')
          .getPublicUrl(fileName);
        
        permanentUrl = publicUrlData.publicUrl;
        console.log('Image uploaded to storage:', permanentUrl);
      } else {
        console.error('Storage upload error:', uploadError);
      }
    } catch (storageError) {
      console.error('Failed to upload image to storage:', storageError);
      // Continue with temp URL if storage fails
    }

    // Save to database
    const { data, error } = await supabase
      .from('generated_images')
      .insert({
        user_id: user.id,
        conversation_id: conversation_id || null,
        prompt: prompt,
        revised_prompt: revisedPrompt,
        image_url: permanentUrl,
        size: size,
        model_used: model,
        cost: cost
      })
      .select()
      .single()

    if (error) {
      console.error('Database error:', error);
      throw error;
    }

    // Update user's daily usage stats
    try {
      const today = new Date().toISOString().split('T')[0];
      
      const { data: existingStats } = await supabase
        .from('usage_stats')
        .select('*')
        .eq('user_id', user.id)
        .eq('date', today)
        .single();
      
      if (existingStats) {
        await supabase
          .from('usage_stats')
          .update({
            total_cost: (existingStats.total_cost || 0) + cost,
            image_count: (existingStats.image_count || 0) + 1,
          })
          .eq('id', existingStats.id);
      } else {
        await supabase
          .from('usage_stats')
          .insert({
            user_id: user.id,
            date: today,
            total_tokens: 0,
            total_cost: cost,
            message_count: 0,
            image_count: 1,
          });
      }
      
      console.log('Image usage recorded');
    } catch (usageError) {
      console.error('Failed to record image usage:', usageError);
    }

    console.log(`Image generated successfully with ${model}`);

    return new Response(
      JSON.stringify(data),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } },
    )
  } catch (error: unknown) {
    const message = error instanceof Error ? error.message : 'Unknown error';
    console.error('Generate image error:', message);
    return new Response(
      JSON.stringify({ error: message }),
      { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } },
    )
  }
})
